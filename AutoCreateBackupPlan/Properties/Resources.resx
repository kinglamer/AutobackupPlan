<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Msg_ErrorCreateFolder" xml:space="preserve">
    <value>Слишком большая длинна пути до папки сохранения. Измените путь: 
</value>
  </data>
  <data name="Msg_CatalogNotExist" xml:space="preserve">
    <value>Отсутствует каталог</value>
  </data>
  <data name="Msg_Create" xml:space="preserve">
    <value>Создал</value>
  </data>
  <data name="OperationCancel" xml:space="preserve">
    <value>Операция отменена</value>
  </data>
  <data name="Msg_Error" xml:space="preserve">
    <value>Ошибка </value>
  </data>
  <data name="Msg_ErrorCheckExistFolders" xml:space="preserve">
    <value>Проблема при проверке наличия папок. Операция прервана</value>
  </data>
  <data name="Msg_ErrorFillAllFields" xml:space="preserve">
    <value>Все поля должны быть заполнены</value>
  </data>
  <data name="Msg_Ready" xml:space="preserve">
    <value>Готово</value>
  </data>
  <data name="QueryStandart_AddAccountToProfileDatabaseMail" xml:space="preserve">
    <value>EXECUTE
            msdb.dbo.sysmail_add_profileaccount_sp
                @profile_name = '{0}',
                @account_name = '{1}',
                @sequence_number = 1;</value>
  </data>
  <data name="BackupExpressBatCommand" xml:space="preserve">
    <value>sqlcmd -S {0} -U {1} -P {2} -i {3}backup_full.sql</value>
  </data>
  <data name="Msg_CatalogAlredyExist" xml:space="preserve">
    <value>В директории {0} уже создан bat файл. Укажите другой каталог.</value>
  </data>
  <data name="Msg_CatalotNotExistCreate" xml:space="preserve">
    <value>Каталог {0} не существует. Вы хотите его создать?</value>
  </data>
  <data name="QueryStandart_ConfigDatabaseMail" xml:space="preserve">
    <value>USE master;
                exec sp_CONFIGURE 'show advanced', 1;                
                RECONFIGURE;                
                exec sp_CONFIGURE 'Database Mail XPs', 1;                
                RECONFIGURE;</value>
  </data>
  <data name="QueryStandart_CreateAccountDatabaseMail" xml:space="preserve">
    <value>EXECUTE
            msdb.dbo.sysmail_add_account_sp
                @account_name = '{4}',
                @description = 'Аккаунт для отправки email сообщений',
                @email_address = '{0}',
                @display_name = 'King.Отправка уведомлений',
                @mailserver_name = '{1}',
                @username = '{2}',
                @password = '{3}';</value>
  </data>
  <data name="QueryStandart_CreateOperator" xml:space="preserve">
    <value>USE msdb;        
                                    EXEC msdb.dbo.sp_add_operator @name='{1}', 
		                            @enabled=1, 
		                            @pager_days=0, 
		                            @email_address='{0}'</value>
  </data>
  <data name="QueryStandart_CreateProfileDatabaseMail" xml:space="preserve">
    <value>EXECUTE msdb.dbo.sysmail_add_profile_sp
                   @profile_name = '{0}',
                   @description = 'Профиль для уведомления о событиях связанных с базой данных';</value>
  </data>
  <data name="QueryStandart_EnableEmailSQLAgent" xml:space="preserve">
    <value>USE msdb;
            EXEC master.dbo.xp_instance_regwrite 
            'HKEY_LOCAL_MACHINE',
            'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', 
            'DatabaseMailProfile', 
            'REG_SZ', '{0}'</value>
  </data>
  <data name="Msg_ErrorEmail" xml:space="preserve">
    <value>Требуется введенный e-mail адрес</value>
  </data>
  <data name="Msg_ErrorEmailFormat" xml:space="preserve">
    <value>e-mail адрес должен иметь правильный формат.\n Например 'someone@example.com'</value>
  </data>
  <data name="Msg_ErrorFieldMustBeNotEmpty" xml:space="preserve">
    <value>Поле не должно быть пустым</value>
  </data>
  <data name="Msg_ErrorSmtp" xml:space="preserve">
    <value>Требуется введенный адрес smtp сервера</value>
  </data>
  <data name="Msg_ErrorSmtpCompare" xml:space="preserve">
    <value>Домен почтового ящика и smtp сервера не совпадает</value>
  </data>
  <data name="QueryExpress_FullBackupExpress" xml:space="preserve">
    <value>declare @pathBackup as varchar(255),
            @nameFile as varchar(40),
            @backupSetId as int

            set @nameFile = 'KING_FULL_' + REPLACE(REPLACE(convert(varchar,GETDATE(), 126),':','_') ,'.','_')
            set @pathBackup =  '{1}' + @nameFile + '.bak'


            BACKUP DATABASE {0} TO  DISK = @pathBackup
            WITH NOFORMAT, NOINIT, NAME = 'Разностная копия базs {0}', SKIP, NOREWIND, NOUNLOAD,  STATS = 10;



            select @backupSetId = position from msdb..backupset where database_name='{0}'
            and backup_set_id=(select max(backup_set_id) from msdb..backupset where database_name='{0}')
            if @backupSetId is null 
            begin 
	            raiserror('Ошибка верификации. Сведения о резервном копировании для базы данных {0} не найдены.', 16, 1) 
            end
            RESTORE VERIFYONLY FROM  DISK = @pathBackup
            WITH FILE = @backupSetId,  NOUNLOAD,  NOREWIND</value>
  </data>
  <data name="QueryStandart_GetConfigsDatabaseMail" xml:space="preserve">
    <value>RECONFIGURE;EXEC sp_configure;</value>
  </data>
  <data name="QueryStandart_TestSendEmail" xml:space="preserve">
    <value>USE msdb;             
                EXECUTE sp_send_dbmail @profile_name = '{1}',
                           @recipients = '{0}',
                           @subject = 'Test message',
                           @body = 'Тестовое сообщение с MS SQL Server отправлено успешно';</value>
  </data>
  <data name="Msg_ErrorValidFields" xml:space="preserve">
    <value>Не все поля заполнены корректно</value>
  </data>
  <data name="Msg_DBMail_ConfigIsReady" xml:space="preserve">
    <value>Системная таблица уже настроена</value>
  </data>
  <data name="Msg_DBMail_ConfigProgress" xml:space="preserve">
    <value>Конфигурируем Database Mail</value>
  </data>
  <data name="Msg_DBMail_OperationExecuted" xml:space="preserve">
    <value>Операция выполнена с кодом: </value>
  </data>
  <data name="Msg_DBMail_ProfileExist" xml:space="preserve">
    <value>Профиль уже создан</value>
  </data>
  <data name="Msg_DBMail_DBMailProfileConfig" xml:space="preserve">
    <value>Конфигурируем Database Mail Profile</value>
  </data>
  <data name="Msg_DBMail_ActivateProfile" xml:space="preserve">
    <value>Активируем в SQL Agente профиль</value>
  </data>
  <data name="Msg_DBMail_AccounExist" xml:space="preserve">
    <value>Аккаунт уже создан</value>
  </data>
  <data name="Msg_DBMail_AccountCreate" xml:space="preserve">
    <value>Создаем Database Mail Account</value>
  </data>
  <data name="Msg_DBMail_AddAccountToDBmail" xml:space="preserve">
    <value>Добавляем Account Database Mail к Profile</value>
  </data>
  <data name="Msg_DBMail_OperatorExist" xml:space="preserve">
    <value>Оператор уже создан</value>
  </data>
  <data name="Msg_DBMail_OperatorCreate" xml:space="preserve">
    <value>Создаем Database Mail Operator</value>
  </data>
  <data name="QueryStandart_CheckExistBackup" xml:space="preserve">
    <value>SELECT 
                                s.backup_set_id,
                                s.database_name,
                                m.physical_device_name,
                                CAST(CAST(s.backup_size / 1000000 AS INT) AS VARCHAR(14)) + ' ' + 'MB' AS bkSize,
                                CAST(DATEDIFF(second, s.backup_start_date,
                                s.backup_finish_date) AS VARCHAR(4)) + ' ' + 'Seconds' TimeTaken,
                                s.backup_start_date,
                                CAST(s.first_lsn AS VARCHAR(50)) AS first_lsn,
                                CAST(s.last_lsn AS VARCHAR(50)) AS last_lsn,
                                CASE s.[type]
                                WHEN 'D' THEN 'Full'
                                WHEN 'I' THEN 'Differential'
                                WHEN 'L' THEN 'Transaction Log'
                                END AS BackupType,
                                s.server_name,
                                s.recovery_model
                                FROM msdb.dbo.backupset s
                                INNER JOIN msdb.dbo.backupmediafamily m ON s.media_set_id = m.media_set_id
                                WHERE s.database_name = '{0}' 
                                and s.[type] like 'D'</value>
  </data>
  <data name="QueryStandart_BaseBackupQuery" xml:space="preserve">
    <value>declare @pathBackup as varchar(255),
            @nameFile as varchar(40),
            @backupSetId as int

            set @nameFile = {2} + {3}
            set @pathBackup =  ''{1}'' + @nameFile + ''.bak''


            BACKUP {4} {0} TO  DISK = @pathBackup
            WITH {5}, NOINIT, NAME = ''Копия базы {0}'', SKIP, NOREWIND, NOUNLOAD,  STATS = 10;



            select @backupSetId = position from msdb..backupset where database_name=''{0}'' 
            and backup_set_id=(select max(backup_set_id) from msdb..backupset where database_name=''{0}'')
            if @backupSetId is null 
            begin 
	            raiserror(''Ошибка верификации. Сведения о резервном копировании для базы данных {0} не найдены.'', 16, 1) 
            end
            RESTORE VERIFYONLY FROM  DISK = @pathBackup
            WITH FILE = @backupSetId,  NOUNLOAD,  NOREWIND</value>
  </data>
  <data name="QueryStandart_ChangeRecoveryModel" xml:space="preserve">
    <value>USE {0} ; ALTER DATABASE {0} SET RECOVERY FULL ;</value>
  </data>
  <data name="QueryStandart_QueryDeleteJob" xml:space="preserve">
    <value>declare @deldate datetime
            set @deldate = getdate()
            EXECUTE master.dbo.xp_delete_file 0,''{0}'',''BAK'',@DelDate, 1</value>
  </data>
  <data name="QueryStandart_DeleteOldBackup" xml:space="preserve">
    <value>declare @deldate datetime
            set @deldate = {1}
            EXECUTE master.dbo.xp_delete_file 0,''{0}'',''BAK'',@DelDate, 1</value>
  </data>
  <data name="QueryStandart_ShrinkTransaction" xml:space="preserve">
    <value>USE {0};            

DECLARE @logName nvarchar(90)

DECLARE log_cursor CURSOR FOR 

select NAME = left(a.NAME,15) from
dbo.sysfiles a
where a.groupid = 0

OPEN log_cursor

FETCH NEXT FROM log_cursor 
INTO @logName

WHILE @@FETCH_STATUS = 0
BEGIN
	DBCC SHRINKFILE (@logName , 0, TRUNCATEONLY)
		
	FETCH NEXT FROM log_cursor 
	INTO @logName
END</value>
  </data>
  <data name="QueryStandart_GetFileStatistic" xml:space="preserve">
    <value>declare @s varchar(max) set @s = '''' select @s = ''&lt;table cellpadding=3 cellspacing=0 border=1&gt; &lt;tr style="color:White;background-color:SteelBlue;font-weight:bold;"&gt;&lt;td&gt;Name&lt;/td&gt;
	            &lt;td&gt;FILEID&lt;/td&gt;
	            &lt;td&gt;FILE_SIZE_MB&lt;/td&gt;
	            &lt;td&gt;SPACE_USED_MB&lt;/td&gt;
	            &lt;td&gt;FREE_SPACE_MB&lt;/td&gt;
	            &lt;td&gt;FILENAME&lt;/td&gt;	
            &lt;/tr&gt;'' +
            cast ((
            Select [Tag] = 1, [Parent] = 0, 
            [tr!1!td!element] = left(a.NAME,15),
            [tr!1!td!element] =  a.FILEID,
             [tr!1!td!element] = convert(decimal(12,2),round(a.size/128.000,2)),
             [tr!1!td!element] =  convert(decimal(12,2),round(fileproperty(a.name,''SpaceUsed'')/128.000,2)),
             [tr!1!td!element] =  convert(decimal(12,2),round((a.size-fileproperty(a.name,''SpaceUsed''))/128.000,2)) ,
             [tr!1!td!element] =  a.FILENAME
            From dbo.sysfiles a
            for xml explicit) as varchar(max))  + ''&lt;/table&gt;''</value>
  </data>
  <data name="QueryStandart_AddJob" xml:space="preserve">
    <value>USE [msdb];

            EXEC  msdb.dbo.sp_add_job @job_name='{0}', 
		    @enabled=1, 
		    @notify_level_eventlog=0, 
		    @notify_level_email=2, 
		    @notify_level_netsend=2, 
		    @notify_level_page=2, 
		    @delete_level=0, 
		    @description='{1}', 
		    @category_name='{3}', 
		    @owner_login_name='sa', 
		    @notify_email_operator_name='{4}';

            EXEC msdb.dbo.sp_add_jobserver @job_name='{0}', @server_name = '{2}';</value>
  </data>
  <data name="QueryStandart_AddJobStep" xml:space="preserve">
    <value>USE [msdb];

            EXEC msdb.dbo.sp_add_jobstep @job_name='{0}', @step_name='{1}', 
		            @step_id={4}, 
		            @cmdexec_success_code=0, 
		            @on_success_action={5}, 
		            @on_fail_action={6}, 
		            @retry_attempts=0, 
		            @retry_interval=0, 
		            @os_run_priority=0, @subsystem='TSQL', 
		            @command='{3}',
                    @database_name='{2}', 
		            @flags=0;</value>
  </data>
  <data name="QueryStandart_AddEmailNotify" xml:space="preserve">
    <value> EXEC msdb.dbo.sp_send_dbmail
            @profile_name = ''{0}'',
              @recipients = ''{1}'',
              @subject = ''{2}'',
              @body = @s,
              @body_format = ''HTML''</value>
  </data>
  <data name="QueryStandart_UpdateJob" xml:space="preserve">
    <value>USE [msdb];

           EXEC msdb.dbo.sp_update_job @job_name='{0}', 
		        @enabled=1, 
		        @start_step_id=1, 
		        @notify_level_eventlog=0, 
		        @notify_level_email={4}, 
		        @notify_level_netsend=2, 
		        @notify_level_page=2, 
		        @delete_level=0, 
		        @description='{1}', 
		        @category_name='{2}', 
		        @owner_login_name='sa', 
		        @notify_email_operator_name='{3}', 
		        @notify_netsend_operator_name='', 
		        @notify_page_operator_name='';</value>
  </data>
  <data name="QueryStandart_JobSchedule" xml:space="preserve">
    <value>USE [msdb];
	
            EXEC msdb.dbo.sp_add_jobschedule @job_name='{0}', @name='{7}', 
		            @enabled=1, 
		            @freq_type={8}, 
		            @freq_interval={2}, 
		            @freq_subday_type={3}, 
		            @freq_subday_interval={4}, 
		            @freq_relative_interval={9}, 
		            @freq_recurrence_factor=1, 
		            @active_start_date={1}, 
		            @active_end_date=99991231, 
		            @active_start_time={5}, 
		            @active_end_time={6};</value>
  </data>
  <data name="Msg_ErrorLookLogs" xml:space="preserve">
    <value>При выполнение возникла ошибка. См. файл логов</value>
  </data>
  <data name="Msg_ErrorOnStage" xml:space="preserve">
    <value>Ошибка на этапе выполнения команды: {0} 
Сведения: {1}</value>
  </data>
  <data name="QueryStandart_CheckExistJob" xml:space="preserve">
    <value>select * from msdb.dbo.sysjobs where name like '{0}'</value>
  </data>
  <data name="Msg_JobExist" xml:space="preserve">
    <value>Задача {0} уже создана в базе данных</value>
  </data>
  <data name="Msg_Query_GetFileStat" xml:space="preserve">
    <value>Получение статистики файлов</value>
  </data>
  <data name="QueryStandart_Part1_CheckDB" xml:space="preserve">
    <value>''declare @s varchar(max) select @s =  ''''&lt;table cellpadding=3 cellspacing=0 border=1&gt; &lt;tr style="color:White;background-color:SteelBlue;font-weight:bold;"&gt; &lt;td&gt;DBName&lt;/td&gt;
                                   &lt;td&gt;Output&lt;/td&gt;
                                   &lt;td&gt;MessageText&lt;/td&gt;
                                   &lt;/tr&gt;''''+
                                   cast ((SELECT [Tag] = 1, [Parent] = 0,  
                                   [tr!1!td!element] = DB_NAME(DbId), '' + 
                                   ''[tr!1!td!element] = CASE WHEN MessageText LIKE ''''%0 allocation errors and 0 consistency errors%'''' THEN 0 ELSE 1 END,
                                   [tr!1!td!element] = MessageText 
                                   FROM #DBCC_OUTPUT 
                                   for xml explicit) as varchar(max))  + ''''&lt;/table&gt;''''</value>
    <comment>//использую не стандартную функцию, т.к. в данном случае это запрос в тексте, и требовалось больше амперсантов</comment>
  </data>
  <data name="QueryStandart_Part2_CheckDB" xml:space="preserve">
    <value> EXEC msdb.dbo.sp_send_dbmail
            @profile_name = ''''{0}'''',
              @recipients = ''''{1}'''',
              @subject = ''''{2}'''',
              @body = @s,
              @body_format = ''''HTML'''';''</value>
    <comment>//использую не стандартную функцию, т.к. в данном случае это запрос в тексте, и требовалось больше амперсантов</comment>
  </data>
  <data name="QueryStandart_Part3_CheckDB" xml:space="preserve">
    <value>declare @dbName varchar(50),
	        @PHYSICAL_ONLY bit = 0
	
            set @dbName = ''{1}''

            IF OBJECT_ID(''tempdb..#DBCC_OUTPUT'') IS NOT NULL
		        DROP TABLE #DBCC_OUTPUT

	CREATE TABLE #DBCC_OUTPUT(
		Error int NOT NULL,
		[Level] int NOT NULL,
		State int NOT NULL,
		MessageText nvarchar(256) NOT NULL,
		RepairLevel int NULL,
		Status int NOT NULL,
		DbId int NOT NULL,
		ObjectId int NOT NULL,
		IndexId int NOT NULL,
		PartitionId int NOT NULL,
		AllocUnitId int NOT NULL,
		[File] int NOT NULL,
		Page int NOT NULL,
		Slot int NOT NULL,
		RefFile int NOT NULL,
		RefPage int NOT NULL,
		RefSlot int NOT NULL,
		Allocation int NOT NULL)

	DECLARE c_databases CURSOR LOCAL FAST_FORWARD
	FOR
	SELECT Name
	FROM master.sys.databases
	WHERE Name = ISNULL(@dbName, Name)

	OPEN c_databases
	
	FETCH NEXT FROM c_databases INTO @dbName

	WHILE @@FETCH_STATUS = 0
	BEGIN

		DECLARE @sql nvarchar(4000)
		SET @sql = ''DBCC CHECKDB(''+ @dbName +'') WITH TABLERESULTS, ALL_ERRORMSGS''
		
		IF @PHYSICAL_ONLY = 1 
			SET @sql = @sql + '', PHYSICAL_ONLY ''


		INSERT INTO #DBCC_OUTPUT
		EXEC(@sql)

		FETCH NEXT FROM c_databases INTO @dbName
	END
	
	CLOSE c_databases
	DEALLOCATE c_databases

	IF NOT EXISTS (
		SELECT 1 FROM #DBCC_OUTPUT 
	)
	BEGIN 
		RAISERROR(''No database matches the name specified.'',10,1)
	END 

    SET @sql = {0}

    EXEC(@sql);</value>
  </data>
  <data name="Msg_Query_CheckDB" xml:space="preserve">
    <value>Выполнение DBCC CHECKDB</value>
  </data>
  <data name="Msg_Query_ShrinkLogs" xml:space="preserve">
    <value>Сжатие логов транзакций</value>
  </data>
  <data name="QueryStandart_DateADD7" xml:space="preserve">
    <value>DATEADD(d,-7 ,getdate())</value>
  </data>
  <data name="QueryStandart_GetDate" xml:space="preserve">
    <value>getdate()</value>
  </data>
  <data name="Msg_Query_DeleteOldCopy" xml:space="preserve">
    <value>Удаление старых копий</value>
  </data>
  <data name="Msg_Query_Sheduler" xml:space="preserve">
    <value>Расписание</value>
  </data>
  <data name="Msg_Query_DeleteTransaction" xml:space="preserve">
    <value>Удаление журналов транзакций</value>
  </data>
  <data name="Msg_Query_DeleteDiff" xml:space="preserve">
    <value>Удаление разностных копий</value>
  </data>
  <data name="QueryStandart_ConfigProfile" xml:space="preserve">
    <value>EXECUTE msdb.dbo.sysmail_help_profile_sp @profile_name = '{0}';</value>
  </data>
  <data name="QueryStandart_ConfigAccount" xml:space="preserve">
    <value>EXECUTE msdb.dbo.sysmail_help_profileaccount_sp @account_name  = '{0}';</value>
  </data>
  <data name="QueryStandart_ConfigOperator" xml:space="preserve">
    <value>EXECUTE msdb.dbo.sp_help_operator @operator_name  = '{0}';</value>
  </data>
  <data name="Msg_RequiredEmial" xml:space="preserve">
    <value>Необходимо указать почту</value>
  </data>
  <data name="Msg_ReadyAddionalTask" xml:space="preserve">
    <value>Настроены задачи дополнительного анализа БД
</value>
  </data>
  <data name="Msg_NotExistEmailAdmin" xml:space="preserve">
    <value>Не настроена почта администраора btCreateNotify_Click</value>
  </data>
  <data name="Msg_NeedManualBackup" xml:space="preserve">
    <value>Для указаной вами базы данных еще не выполнялось резервное копирование данных. 
Необходимо выполнить его в ручную, чтобы начали формировать резервные копии журналов транзакций</value>
  </data>
  <data name="QueryStandart_DeleteJobs" xml:space="preserve">
    <value>USE [msdb];
                                    declare @jobId varchar(90)

                                    declare job_cursor cursor for
                                    select   
                                        j.job_id
                                    from dbo.sysjobs j
                                    where j.name like 'King.%'

                                    open job_cursor

                                    FETCH NEXT FROM job_cursor 
                                    INTO @jobId

                                    WHILE @@FETCH_STATUS = 0
                                    BEGIN
	                                    EXEC sp_delete_job @job_id=@jobId, @delete_unused_schedule=1

	                                    FETCH NEXT FROM job_cursor 
	                                    INTO @jobId
                                    end</value>
  </data>
  <data name="QueryStandart_DeleteProfilesDBMail" xml:space="preserve">
    <value>USE msdb ;
                EXECUTE sysmail_delete_profileaccount_sp @profile_name = '{2}', @account_name = '{0}';
                EXECUTE sysmail_delete_profile_sp @profile_name = '{2}' ;
                EXECUTE sysmail_delete_account_sp @account_name = '{0}';
                EXEC sp_delete_operator @name = '{1}';</value>
  </data>
  <data name="Msg_DeletedJobs" xml:space="preserve">
    <value>Все созданные ранее задачи удалены
</value>
  </data>
  <data name="Msg_Delete_ConfigDBMail" xml:space="preserve">
    <value>Удалены настройки DatabaseMail
</value>
  </data>
  <data name="Msg_ConfigDBMail" xml:space="preserve">
    <value>Настроен модуль почты
</value>
  </data>
  <data name="Msg_NeedRebootAgent" xml:space="preserve">
    <value>Необходимо перезапустить вручную SQL Agent! Иначе не будут работать уведомления по почте</value>
  </data>
  <data name="Msg_NotConfiguretedDBMail" xml:space="preserve">
    <value>Не настроен DatabaseMail</value>
  </data>
  <data name="QueryStandart_TimeStamp" xml:space="preserve">
    <value>REPLACE(REPLACE(convert(varchar,GETDATE(), 126),'':'',''_'') ,''.'',''_'')</value>
    <comment>У каждого созданного файла бэкапа, будет ставиться временная метка, когда он был создан, с точностью до секунд</comment>
  </data>
  <data name="Msg_Query_Part1_TaskCheckDB" xml:space="preserve">
    <value>King.DBCC.CHECKDB</value>
  </data>
  <data name="Msg_Query_Part2_TaskCheckDB" xml:space="preserve">
    <value>Проверка БД перед созданием полной копии базы</value>
  </data>
  <data name="Msg_Query_Part3_TaskCheckDB" xml:space="preserve">
    <value>Проверка</value>
  </data>
  <data name="Msg_Query_Part1_Staticstic" xml:space="preserve">
    <value>King.File.Statistics</value>
  </data>
  <data name="Msg_Query_Part2_Staticstic" xml:space="preserve">
    <value>Информация о том, как распределено место в файловых группах базы</value>
  </data>
  <data name="Msg_Query_Part3_Staticstic" xml:space="preserve">
    <value>Получение статистики</value>
  </data>
  <data name="Msg_Query_Part1_Transaction" xml:space="preserve">
    <value>King.Backup.Transaction</value>
  </data>
  <data name="Msg_Query_Part2_Transaction" xml:space="preserve">
    <value>Копия журналов транзакций базы данных</value>
  </data>
  <data name="Msg_Query_Copy" xml:space="preserve">
    <value>Копия</value>
  </data>
  <data name="Msg_Query_Part1_Diff" xml:space="preserve">
    <value>King.Backup.Different</value>
  </data>
  <data name="Msg_Query_Part2_Diff" xml:space="preserve">
    <value>Создание разностной копии базы данных. С последующим удалением резервных копий журналов транзакций</value>
  </data>
  <data name="Msg_Query_Part1_Full" xml:space="preserve">
    <value>King.Backup.Full</value>
  </data>
  <data name="Msg_Query_Part2_Full" xml:space="preserve">
    <value>Создание полной копии БД. С последующим удалением журналов транзакций и разностных копий.</value>
  </data>
  <data name="Msg_JobBackupReady" xml:space="preserve">
    <value>Настроен задачи резервного копирования БД
</value>
  </data>
  <data name="Msg_Query_Part1_Master" xml:space="preserve">
    <value>King.Backup.master</value>
  </data>
  <data name="Msg_Query_Part2_Master" xml:space="preserve">
    <value>Копия системной базы данных master</value>
  </data>
  <data name="Msg_Query_Part1_MSDB" xml:space="preserve">
    <value>King.Backup.msdb</value>
  </data>
  <data name="Msg_Query_Part2_MSDB" xml:space="preserve">
    <value>Копия системной базы данных msdb</value>
  </data>
  <data name="Msg_BackupSystemDBReady" xml:space="preserve">
    <value>Все задачи резервного копирования системных баз настроены!
</value>
  </data>
  <data name="Msg_Query_OperatorName" xml:space="preserve">
    <value>King.Operator</value>
  </data>
  <data name="Msg_Query_Profile" xml:space="preserve">
    <value>King.Profile</value>
  </data>
  <data name="Msg_Query_Account" xml:space="preserve">
    <value>King.Account</value>
  </data>
</root>